<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Soapbox Superstock Cars Simulation</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
  <!-- Three.js Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- Cannon.js Physics Engine -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon-es/0.18.0/cannon-es.min.js"></script>
</head>
<body>
<script>
  let scene, camera, renderer, world;
  const cars = [];
  const cones = [];
  
  // Initialize scene, physics and objects
  function init() {
    // THREE.js Scene Setup
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(0, 5, 10);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Add a directional light for clarity
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 10, 5);
    scene.add(light);

    // Cannon.js Physics World
    world = new CANNON.World();
    world.gravity.set(0, -9.8, 0);
    world.broadphase = new CANNON.NaiveBroadphase();
    world.solver.iterations = 10;

    // Create a sloped ground (inclined plane)
    const groundMaterial = new CANNON.Material("groundMaterial");
    const groundBody = new CANNON.Body({
      mass: 0,
      material: groundMaterial
    });
    // Use a plane shape and rotate it to get an incline
    groundBody.addShape(new CANNON.Plane());
    // Rotate around the X-axis to create a slope (about 22.5Â° incline)
    groundBody.quaternion.setFromEuler(-Math.PI / 8, 0, 0);
    world.addBody(groundBody);

    // Visual ground in Three.js
    const groundGeo = new THREE.PlaneGeometry(50, 50);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x228B22, side: THREE.DoubleSide });
    const groundMesh = new THREE.Mesh(groundGeo, groundMat);
    groundMesh.rotation.x = -Math.PI / 8;
    scene.add(groundMesh);

    // Create two cars
    createCar(-2, 2, 0xff0000); // Red car
    createCar(2, 2, 0x0000ff);  // Blue car

    // Create traffic cones as obstacles
    for (let i = -4; i <= 4; i += 2) {
      createCone(i, -2);
    }

    // Resize event listener
    window.addEventListener('resize', onWindowResize, false);

    animate();
  }

  // Adjust renderer and camera aspect on window resize
  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  // Create a car with a box body and four wheels
  function createCar(x, z, color) {
    // Create a group for the car visual
    const carGroup = new THREE.Group();
    
    // Car body
    const bodyGeometry = new THREE.BoxGeometry(1, 0.5, 2);
    const bodyMaterial = new THREE.MeshStandardMaterial({ color: color });
    const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
    bodyMesh.position.set(0, 0.25, 0);
    carGroup.add(bodyMesh);

    // Wheels - four cylinders
    const wheelGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16);
    const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const wheelPositions = [
      [-0.4, 0, 0.8],
      [0.4, 0, 0.8],
      [-0.4, 0, -0.8],
      [0.4, 0, -0.8]
    ];
    wheelPositions.forEach(pos => {
      const wheel = new THREE.Mesh(wheelGeo, wheelMat);
      wheel.rotation.z = Math.PI / 2;
      wheel.position.set(pos[0], 0.1, pos[2]);
      carGroup.add(wheel);
    });
    
    scene.add(carGroup);

    // Create a corresponding Cannon.js body for the car
    const boxShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.25, 1));
    const carBody = new CANNON.Body({
      mass: 5,
      shape: boxShape,
      position: new CANNON.Vec3(x, 2, z)
    });
    world.addBody(carBody);

    // Store both visual and physics objects
    cars.push({ group: carGroup, body: carBody });
  }

  // Create a traffic cone as an obstacle
  function createCone(x, z) {
    // Cone visual using a cone geometry
    const coneGeo = new THREE.ConeGeometry(0.3, 1, 16);
    const coneMat = new THREE.MeshStandardMaterial({ color: 0xffa500 });
    const coneMesh = new THREE.Mesh(coneGeo, coneMat);
    scene.add(coneMesh);

    // Create a corresponding physics body (approximate with a cylinder)
    const coneShape = new CANNON.Cylinder(0.3, 0.3, 1, 16);
    const coneBody = new CANNON.Body({
      mass: 1,
      shape: coneShape,
      position: new CANNON.Vec3(x, 0.5, z)
    });
    world.addBody(coneBody);

    cones.push({ mesh: coneMesh, body: coneBody });
  }

  // Animation loop: update physics, sync positions, and render scene
  function animate() {
    requestAnimationFrame(animate);
    
    // Step the physics world
    world.step(1/60);

    // Update cars from physics bodies
    cars.forEach(car => {
      car.group.position.copy(car.body.position);
      car.group.quaternion.copy(car.body.quaternion);
    });

    // Update cones from physics bodies
    cones.forEach(cone => {
      cone.mesh.position.copy(cone.body.position);
      cone.mesh.quaternion.copy(cone.body.quaternion);
    });

    // Camera follows the first car with a slight offset
    if(cars.length > 0) {
      const targetPos = new THREE.Vector3(
        cars[0].body.position.x,
        cars[0].body.position.y + 2,
        cars[0].body.position.z + 5
      );
      camera.position.lerp(targetPos, 0.05);
      camera.lookAt(cars[0].body.position);
    }

    renderer.render(scene, camera);
  }

  // Start the simulation
  init();
</script>
</body>
</html>
